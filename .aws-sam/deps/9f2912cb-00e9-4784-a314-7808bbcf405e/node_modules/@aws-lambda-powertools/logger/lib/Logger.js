"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const formatter_1 = require("./formatter");
const log_1 = require("./log");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const config_1 = require("./config");
/**
 * ## Intro
 * The Logger utility provides an opinionated logger with output structured as JSON.
 *
 * ## Key features
 *  * Capture key fields from Lambda context, cold start and structures logging output as JSON
 *  * Log Lambda context when instructed (disabled by default)
 *  * Log sampling prints all logs for a percentage of invocations (disabled by default)
 *  * Append additional keys to structured log at any point in time
 *
 * ## Usage
 *
 * For more usage examples, see [our documentation](https://awslabs.github.io/aws-lambda-powertools-typescript/latest/core/logger/).
 *
 * ### Basic usage
 *
 * @example
 * ```typescript
 * import { Logger } from "@aws-lambda-powertools/logger";
 *
 * // Logger parameters fetched from the environment variables:
 * const logger = new Logger();
 * ```
 *
 * ### Functions usage with manual instrumentation
 *
 * If you prefer to manually instrument your Lambda handler you can use the methods in the Logger class directly.
 *
 * @example
 * ```typescript
 * import { Logger } from "@aws-lambda-powertools/logger";
 *
 * const logger = new Logger();
 *
 * export const handler = async (_event, context) => {
 *     logger.addContext(context);
 *     logger.info("This is an INFO log with some context");
 * };
 * ```
 *
 * ### Functions usage with middleware
 *
 * If you use function-based Lambda handlers you can use the [injectLambdaContext()](#injectLambdaContext)
 * middy middleware to automatically add context to your Lambda logs.
 *
 * @example
 * ```typescript
 * import { Logger, injectLambdaContext } from "@aws-lambda-powertools/logger";
 * import middy from '@middy/core';
 *
 * const logger = new Logger();
 *
 * const lambdaHandler = async (_event: any, _context: any) => {
 *     logger.info("This is an INFO log with some context");
 * };
 *
 * export const handler = middy(lambdaHandler).use(injectLambdaContext(logger));
 * ```
 *
 * ### Object oriented usage with decorators
 *
 * If instead you use TypeScript classes to wrap your Lambda handler you can use the [@logger.injectLambdaContext()](./_aws_lambda_powertools_logger.Logger.html#injectLambdaContext) decorator.
 *
 * @example
 * ```typescript
 * import { Logger } from "@aws-lambda-powertools/logger";
 * import { LambdaInterface } from '@aws-lambda-powertools/commons';
 *
 * const logger = new Logger();
 *
 * class Lambda implements LambdaInterface {
 *     // Decorate your handler class method
 *     @logger.injectLambdaContext()
 *     public async handler(_event: any, _context: any): Promise<void> {
 *         logger.info("This is an INFO log with some context");
 *     }
 * }
 *
 * export const myFunction = new Lambda();
 * export const handler = myFunction.handler;
 * ```
 *
 * @class
 * @implements {ClassThatLogs}
 * @see https://awslabs.github.io/aws-lambda-powertools-typescript/latest/core/logger/
 */
class Logger {
    /**
     * It initializes the Logger class with an optional set of options (settings).
     * *
     * @param {LoggerOptions} options
     */
    constructor(options = {}) {
        this.logLevelThresholds = {
            DEBUG: 8,
            INFO: 12,
            WARN: 16,
            ERROR: 20,
        };
        this.logsSampled = false;
        this.persistentLogAttributes = {};
        this.powertoolLogData = {};
        this.setOptions(options);
    }
    /**
     * It adds the current Lambda function's invocation context data to the powertoolLogData property of the instance.
     * This context data will be part of all printed log items.
     *
     * @param {Context} context
     * @returns {void}
     */
    addContext(context) {
        Logger.evaluateColdStartOnce();
        const lambdaContext = {
            invokedFunctionArn: context.invokedFunctionArn,
            coldStart: Logger.getColdStartValue(),
            awsRequestId: context.awsRequestId,
            memoryLimitInMB: Number(context.memoryLimitInMB),
            functionName: context.functionName,
            functionVersion: context.functionVersion,
        };
        this.addToPowertoolLogData({
            lambdaContext,
        });
    }
    /**
     * It adds the given attributes (key-value pairs) to all log items generated by this Logger instance.
     *
     * @param {LogAttributes} attributes
     * @returns {void}
     */
    addPersistentLogAttributes(attributes) {
        (0, lodash_merge_1.default)(this.persistentLogAttributes, attributes);
    }
    /**
     * Alias for addPersistentLogAttributes.
     *
     * @param {LogAttributes} attributes
     * @returns {void}
     */
    appendKeys(attributes) {
        this.addPersistentLogAttributes(attributes);
    }
    /**
     * It creates a separate Logger instance, identical to the current one
     * It's possible to overwrite the new instance options by passing them.
     *
     * @param {LoggerOptions} options
     * @returns {Logger}
     */
    createChild(options = {}) {
        return (0, lodash_clonedeep_1.default)(this).setOptions(options);
    }
    /**
     * It prints a log item with level DEBUG.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | unknown} extraInput
     * @returns {void}
     */
    debug(input, ...extraInput) {
        this.processLogItem('DEBUG', input, extraInput);
    }
    /**
     * It prints a log item with level ERROR.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | unknown} extraInput
     * @returns {void}
     */
    error(input, ...extraInput) {
        this.processLogItem('ERROR', input, extraInput);
    }
    /**
     * It evaluates whether the current Lambda function invocation has a cold start or not.
     *
     * @static
     * @returns {void}
     */
    static evaluateColdStartOnce() {
        if (!Logger.getColdStartEvaluatedValue()) {
            Logger.evaluateColdStart();
        }
    }
    /**
     * It returns a boolean value which is true if the current Lambda function cold start has been already evaluated, false otherwise.
     *
     * @static
     * @returns {boolean}
     */
    static getColdStartEvaluatedValue() {
        return Logger.coldStartEvaluated;
    }
    /**
     * It returns an optional boolean value, true if the current Lambda function invocation has a cold start, false otherwise.
     *
     * @static
     * @returns {boolean | undefined}
     */
    static getColdStartValue() {
        return Logger.coldStart;
    }
    /**
     * It returns a boolean value, if true all the logs will be printed.
     *
     * @returns {boolean}
     */
    getLogsSampled() {
        return this.logsSampled;
    }
    /**
     * It prints a log item with level INFO.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | unknown} extraInput
     * @returns {void}
     */
    info(input, ...extraInput) {
        this.processLogItem('INFO', input, extraInput);
    }
    /**
     * Method decorator that adds the current Lambda function context as extra
     * information in all log items.
     * The decorator can be used only when attached to a Lambda function handler which
     * is written as method of a class, and should be declared just before the handler declaration.
     *
     * @see https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators
     * @returns {HandlerMethodDecorator}
     */
    injectLambdaContext() {
        return (target, _propertyKey, descriptor) => {
            const originalMethod = descriptor.value;
            descriptor.value = (event, context, callback) => {
                this.addContext(context);
                return originalMethod?.apply(target, [event, context, callback]);
            };
        };
    }
    /**
     * If the sample rate feature is enabled, the calculation that determines whether the logs
     * will actually be printed or not for this invocation is done when the Logger class is
     * initialized.
     * This method will repeat that calculation (with possible different outcome).
     *
     * @returns {void}
     */
    refreshSampleRateCalculation() {
        this.setLogsSampled();
    }
    /**
     * It sets the value of a flag static propriety that tracks whether
     * the cold start evaluation already took place.
     *
     * @param {boolean} value
     * @static
     * @returns {void}
     */
    static setColdStartEvaluatedValue(value) {
        Logger.coldStartEvaluated = value;
    }
    /**
     * It sets the value of a flag static propriety that tracks whether
     * the current Lambda invocation experienced a cold start.
     *
     * @static
     * @param {boolean | undefined} value
     * @returns {void}
     */
    static setColdStartValue(value) {
        Logger.coldStart = value;
    }
    /**
     * It sets the user-provided sample rate value.
     *
     * @param {number} [sampleRateValue]
     * @returns {void}
     */
    setSampleRateValue(sampleRateValue) {
        this.powertoolLogData.sampleRateValue =
            sampleRateValue ||
                this.getCustomConfigService()?.getSampleRateValue() ||
                this.getEnvVarsService().getSampleRateValue();
    }
    /**
     * It prints a log item with level WARN.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | unknown} extraInput
     * @returns {void}
     */
    warn(input, ...extraInput) {
        this.processLogItem('WARN', input, extraInput);
    }
    /**
     * It stores information that is printed in all log items.
     *
     * @param {Partial<PowertoolLogData>} attributesArray
     * @private
     * @returns {void}
     */
    addToPowertoolLogData(...attributesArray) {
        attributesArray.forEach((attributes) => {
            (0, lodash_merge_1.default)(this.powertoolLogData, attributes);
        });
    }
    /**
     * It processes a particular log item so that it can be printed to stdout:
     * - Merges ephemeral log attributes with persistent log attributes (printed for all logs) and additional info;
     * - Formats all the log attributes;
     *
     * @private
     * @param {LogLevel} logLevel
     * @param {LogItemMessage} input
     * @param {LogItemExtraInput} extraInput
     * @returns {LogItem}
     */
    createAndPopulateLogItem(logLevel, input, extraInput) {
        // TODO: this method's logic is hard to understand, there is an opportunity here to simplify this logic.
        const unformattedBaseAttributes = (0, lodash_merge_1.default)({
            logLevel,
            timestamp: new Date(),
            message: typeof input === 'string' ? input : input.message,
        }, this.getPowertoolLogData());
        const logItem = new log_1.LogItem({
            baseAttributes: this.getLogFormatter().formatAttributes(unformattedBaseAttributes),
            persistentAttributes: this.getPersistentLogAttributes(),
        });
        // Add ephemeral attributes
        if (typeof input !== 'string') {
            logItem.addAttributes(input);
        }
        extraInput.forEach((item) => {
            const attributes = item instanceof Error ? { error: item } : item;
            logItem.addAttributes(attributes);
        });
        return logItem;
    }
    /**
     * It evaluates whether the current Lambda invocation experienced a
     * cold start.
     *
     * @private
     * @static
     * @returns {void}
     */
    static evaluateColdStart() {
        const coldStartValue = Logger.getColdStartValue();
        if (typeof coldStartValue === 'undefined') {
            Logger.setColdStartValue(true);
        }
        else if (coldStartValue) {
            Logger.setColdStartValue(false);
        }
        else {
            Logger.setColdStartValue(false);
        }
        Logger.setColdStartEvaluatedValue(true);
    }
    /**
     * It returns the custom config service, an abstraction used to fetch environment variables.
     *
     * @private
     * @returns {ConfigServiceInterface | undefined}
     */
    getCustomConfigService() {
        return this.customConfigService;
    }
    /**
     * It returns the instance of a service that fetches environment variables.
     *
     * @private
     * @returns {EnvironmentVariablesService}
     */
    getEnvVarsService() {
        return this.envVarsService;
    }
    /**
     * It returns the instance of a service that formats the structure of a
     * log item's keys and values in the desired way.
     *
     * @private
     * @returns {LogFormatterInterface}
     */
    getLogFormatter() {
        return this.logFormatter;
    }
    /**
     * It returns the log level set for the Logger instance.
     *
     * @private
     * @returns {LogLevel}
     */
    getLogLevel() {
        return this.logLevel;
    }
    /**
     * It returns the persistent log attributes, which are the attributes
     * that will be logged in all log items.
     *
     * @private
     * @returns {LogAttributes}
     */
    getPersistentLogAttributes() {
        return this.persistentLogAttributes;
    }
    /**
     * It returns information that will be added in all log item by
     * this Logger instance (different from user-provided persistent attributes).
     *
     * @private
     * @returns {LogAttributes}
     */
    getPowertoolLogData() {
        return this.powertoolLogData;
    }
    /**
     * It returns the numeric sample rate value.
     *
     * @private
     * @returns {number}
     */
    getSampleRateValue() {
        if (!this.powertoolLogData?.sampleRateValue) {
            this.setSampleRateValue();
        }
        return this.powertoolLogData?.sampleRateValue;
    }
    /**
     * It returns true if the provided log level is valid.
     *
     * @param {LogLevel} logLevel
     * @private
     * @returns {boolean}
     */
    isValidLogLevel(logLevel) {
        return typeof logLevel === 'string' && logLevel.toUpperCase() in this.logLevelThresholds;
    }
    /**
     * It prints a given log with given log level.
     *
     * @param {LogLevel} logLevel
     * @param {LogItem} log
     * @private
     */
    printLog(logLevel, log) {
        log.prepareForPrint();
        const consoleMethod = logLevel.toLowerCase();
        console[consoleMethod](JSON.stringify(log.getAttributes(), this.removeCircularDependencies()));
    }
    /**
     * It prints a given log with given log level.
     *
     * @param {LogLevel} logLevel
     * @param {LogItem} log
     * @private
     */
    processLogItem(logLevel, input, extraInput) {
        if (!this.shouldPrint(logLevel)) {
            return;
        }
        this.printLog(logLevel, this.createAndPopulateLogItem(logLevel, input, extraInput));
    }
    /**
     * When the data added in the log item contains object references,
     * JSON.stringify() doesn't try to solve them and instead throws an error: TypeError: cyclic object value.
     * To mitigate this issue, this method will find and remove all cyclic references.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value
     * @private
     */
    removeCircularDependencies() {
        const references = new WeakSet();
        return (key, value) => {
            let item = value;
            if (item instanceof Error) {
                item = this.getLogFormatter().formatError(item);
            }
            if (typeof item === 'object' && value !== null) {
                if (references.has(item)) {
                    return;
                }
                references.add(item);
            }
            return item;
        };
    }
    /**
     * Sets the Logger's customer config service instance, which will be used
     * to fetch environment variables.
     *
     * @private
     * @param {ConfigServiceInterface} customConfigService
     * @returns {void}
     */
    setCustomConfigService(customConfigService) {
        this.customConfigService = customConfigService ? customConfigService : undefined;
    }
    /**
     * Sets the Logger's custom config service instance, which will be used
     * to fetch environment variables.
     *
     * @private
     * @param {ConfigServiceInterface} customConfigService
     * @returns {void}
     */
    setEnvVarsService() {
        this.envVarsService = new config_1.EnvironmentVariablesService();
    }
    /**
     * It sets the log formatter instance, in charge of giving a custom format
     * to the structured logs
     *
     * @private
     * @param {LogFormatterInterface} logFormatter
     * @returns {void}
     */
    setLogFormatter(logFormatter) {
        this.logFormatter = logFormatter || new formatter_1.PowertoolLogFormatter();
    }
    /**
     * It sets the Logger's instance log level.
     *
     * @private
     * @param {LogLevel} logLevel
     * @returns {void}
     */
    setLogLevel(logLevel) {
        if (this.isValidLogLevel(logLevel)) {
            this.logLevel = logLevel.toUpperCase();
            return;
        }
        const customConfigValue = this.getCustomConfigService()?.getLogLevel();
        if (this.isValidLogLevel(customConfigValue)) {
            this.logLevel = customConfigValue.toUpperCase();
            return;
        }
        const envVarsValue = this.getEnvVarsService().getLogLevel();
        if (this.isValidLogLevel(envVarsValue)) {
            this.logLevel = envVarsValue.toUpperCase();
            return;
        }
        this.logLevel = Logger.defaultLogLevel;
    }
    /**
     * If the sample rate feature is enabled, it sets a property that tracks whether this Lambda function invocation
     * will print logs or not.
     *
     * @private
     * @returns {void}
     */
    setLogsSampled() {
        const sampleRateValue = this.getSampleRateValue();
        // TODO: revisit Math.random() as it's not a real randomization
        this.logsSampled = sampleRateValue !== undefined && (sampleRateValue === 1 || Math.random() < sampleRateValue);
    }
    /**
     * It configures the Logger instance settings that will affect the Logger's behaviour
     * and the content of all logs.
     *
     * @private
     * @param {LoggerOptions} options
     * @returns {Logger}
     */
    setOptions(options) {
        const { logLevel, serviceName, sampleRateValue, logFormatter, customConfigService, persistentLogAttributes, environment, } = options;
        this.setEnvVarsService();
        this.setCustomConfigService(customConfigService);
        this.setLogLevel(logLevel);
        this.setSampleRateValue(sampleRateValue);
        this.setLogsSampled();
        this.setLogFormatter(logFormatter);
        this.setPowertoolLogData(serviceName, environment);
        this.addPersistentLogAttributes(persistentLogAttributes);
        return this;
    }
    /**
     * It adds important data to the Logger instance that will affect the content of all logs.
     *
     * @param {string} serviceName
     * @param {Environment} environment
     * @param {LogAttributes} persistentLogAttributes
     * @private
     * @returns {void}
     */
    setPowertoolLogData(serviceName, environment, persistentLogAttributes = {}) {
        this.addToPowertoolLogData({
            awsRegion: this.getEnvVarsService().getAwsRegion(),
            environment: environment ||
                this.getCustomConfigService()?.getCurrentEnvironment() ||
                this.getEnvVarsService().getCurrentEnvironment(),
            sampleRateValue: this.getSampleRateValue(),
            serviceName: serviceName || this.getCustomConfigService()?.getServiceName() || this.getEnvVarsService().getServiceName() || Logger.defaultServiceName,
            xRayTraceId: this.getEnvVarsService().getXrayTraceId(),
        }, persistentLogAttributes);
    }
    /**
     * It checks whether the current log item should/can be printed.
     *
     * @param {string} serviceName
     * @param {Environment} environment
     * @param {LogAttributes} persistentLogAttributes
     * @private
     * @returns {boolean}
     */
    shouldPrint(logLevel) {
        if (this.logLevelThresholds[logLevel] >= this.logLevelThresholds[this.getLogLevel()]) {
            return true;
        }
        return this.getLogsSampled();
    }
}
exports.Logger = Logger;
Logger.coldStart = undefined;
Logger.coldStartEvaluated = false;
Logger.defaultLogLevel = 'INFO';
Logger.defaultServiceName = 'service_undefined';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9nZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0xvZ2dlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSwyQ0FBMkU7QUFDM0UsK0JBQWdDO0FBQ2hDLHdFQUF5QztBQUN6QyxnRUFBaUM7QUFDakMscUNBQStFO0FBZS9FOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUZHO0FBQ0gsTUFBTSxNQUFNO0lBK0JWOzs7O09BSUc7SUFDSCxZQUFtQixVQUF5QixFQUFFO1FBbEI3Qix1QkFBa0IsR0FBdUI7WUFDeEQsS0FBSyxFQUFFLENBQUM7WUFDUixJQUFJLEVBQUUsRUFBRTtZQUNSLElBQUksRUFBRSxFQUFFO1lBQ1IsS0FBSyxFQUFFLEVBQUU7U0FDVixDQUFDO1FBRU0sZ0JBQVcsR0FBWSxLQUFLLENBQUM7UUFFN0IsNEJBQXVCLEdBQW1CLEVBQUUsQ0FBQztRQUU3QyxxQkFBZ0IsR0FBdUMsRUFBRSxDQUFDO1FBUWhFLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFVBQVUsQ0FBQyxPQUFnQjtRQUNoQyxNQUFNLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUMvQixNQUFNLGFBQWEsR0FBbUM7WUFDcEQsa0JBQWtCLEVBQUUsT0FBTyxDQUFDLGtCQUFrQjtZQUM5QyxTQUFTLEVBQUUsTUFBTSxDQUFDLGlCQUFpQixFQUFFO1lBQ3JDLFlBQVksRUFBRSxPQUFPLENBQUMsWUFBWTtZQUNsQyxlQUFlLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUM7WUFDaEQsWUFBWSxFQUFFLE9BQU8sQ0FBQyxZQUFZO1lBQ2xDLGVBQWUsRUFBRSxPQUFPLENBQUMsZUFBZTtTQUN6QyxDQUFDO1FBRUYsSUFBSSxDQUFDLHFCQUFx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